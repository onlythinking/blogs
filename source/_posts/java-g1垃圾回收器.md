---
title: java G1垃圾回收器
date: 2020-12-08 13:51:51
tags: jvm
categories: java
copyright: true
top: 1
typora-root-url: ../
typora-copy-images-to: ../images
---

## 什么是垃圾回收

程序内存管理分手动和自动。自动就像JVM实现了内存自动回收。

手动内存管理，需要我们编程的时候显式分配和释放数据存储空间，但如果忘记释放，会造成严重的**内存泄漏**问题。

```c
 		//申请40MB内存
    int* p = malloc(1024 * 1024 * 10 * sizeof(int));
    //释放内存
    free(p);
```

显式分配和释放很容易就造成内存泄漏。因此我们希望有一种能自动回收内存的方法，这样就可以消除人为造成的错误。我们将这种自动化称为垃圾收集（简称GC）

现在很多高级编程语言都具备GC的功能。



## GC算法基础

所有的GC算法基本上都处理两方面内容，当然不同的GC实现细节各有不同。

- 找出所有存活对象
- 删除未使用的对象和整理等



#### 标记活动对象

把握一个原则java gc 是通过追踪活动对象进行标记，未被标记的对象记为空闲状态。

每个对象树都具有一个或多个根对象。 特殊对象称为**Gc Roots**,始终可以访问， 有以下四种

- **局部变量**通过线程堆栈保持活动状态，所以它是GC的根。
- **活动Java线程**始终被视为活动对象，因此是GC根。这对于线程局部变量尤其重要。
- **静态变量**由其类引用。这一事实使它们事实上成为GC的根源。类本身可以被垃圾收集，这将删除所有引用的静态变量。通常，当我们使用应用程序服务器，[OSGi容器](http://www.wikipedia.com/osgi)或类加载器时，这特别重要。我们将在“问题模式”部分讨论相关问题。
- **JNI引用**是本机代码作为JNI调用的一部分创建的Java对象。这样创建的对象将被特别对待，因为JVM不知道本机代码是否正在引用它。这些对象代表了一种非常特殊的GC根形式，我们将在下面的“问题模式”部分中对其进行更详细的研究。

如下图所示，GC遍历内存中的整个对象图，从那些垃圾回收根开始，然后是从根到其他对象（例如实例字段）的引用。GC访问的每个对象都 **标记** 为活动对象。

活动对象表示为蓝色。标记阶段结束后，将标记每个活动对象。因此，所有其他对象（图中的灰色数据结构）从GC根目录都无法访问，这意味着您的应用程序无法再使用该无法访问的对象。此类对象被视为垃圾，GC应在以下阶段将其清除。

- 需要停止应用程序线程以进行标记，因为如果图形一直在变化，您将无法真正遍历图形。当应用程序线程暂时停止以使JVM可以从事家务活动时，这种情况称为 **安全点，** 导致 **Stop The World暂停**。可以出于各种原因触发安全点，但是到目前为止，垃圾回收是引入安全点的最常见原因。
- 暂停的持续时间既不取决于堆中的对象总数，也不取决于堆的大小，而取决于**活动对象**的数量 **。** 因此，增加堆大小不会直接影响标记阶段的持续时间。



![](/images/Java-GC-mark-and-sweep.png)



#### 删除空闲对象